" vimrc: vim initialization script

" Apply vim defaults
"
if (&compatible)
  set nocompatible
endif

" Apply vim defaults even if +eval is missing
"
silent! while (0)
set nocompatible
silent! endwhile

" Always use UTF-8 encoding
"
set encoding=utf-8

" Set the leader key (i.e. <leader>)
"
let g:mapleader = ','

" Clear the rc autocmd group
"
if (has('autocmd'))
  augroup rc
    autocmd!
  augroup END
endif


" Use pipes for shell commands instead of temporary files
"
if (has('job') && has('channel') && has("filterpipe"))
  set noshelltemp
else
endif

" Skip the rest if this is actually VSCode
"
if (exists('g:vscode'))
  finish
endif

" Install Vim-Plug
"
if (empty(glob('~/.vim/autoload/plug.vim')))
  silent !curl -fLo ~/.vim/autoload/plug.vim --create-dirs
        \ 'https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim'
  if (has('autocmd'))
    autocmd rc VimEnter * PlugInstall --sync | source $MYVIMRC
  endif
endif

" Load plugins
"
call plug#begin(join(split(&runtimepath, ',')[:0] + ['plug'], '/'))
"
" NOTE: use single quotes around plugin names

Plug 'junegunn/fzf', { 'do': { -> fzf#install() } }
Plug 'junegunn/fzf.vim'
Plug 'majutsushi/tagbar'
Plug 'ctrlpvim/ctrlp.vim'
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-fugitive'
Plug 'tpope/vim-repeat'
Plug 'mhinz/vim-startify'
Plug 'hashivim/vim-terraform'
Plug 'pangloss/vim-javascript'
Plug 'davidhalter/jedi-vim'
Plug 'github/copilot.vim'
Plug 'haishanh/night-owl.vim'
Plug 'macguirerintoul/night_owl_light.vim'
Plug 'arzg/vim-colors-xcode'
Plug 'mhinz/vim-janah'
Plug 'zeis/vim-kolor'
Plug 'connorholyday/vim-snazzy'
Plug 'junegunn/seoul256.vim'
Plug 'tpope/vim-surround'
Plug 'jlanzarotta/bufexplorer'
Plug 'vim-airline/vim-airline'
Plug 'vim-airline/vim-airline-themes'
Plug 'edkolev/tmuxline.vim'
Plug 'ryanoasis/vim-devicons'
"Plug 'ycm-core/YouCompleteMe'

let g:jedi#auto_initialization = 1
let g:jedi#completions_enabled = 0
let g:jedi#show_call_signatures = 0

let g:tmuxline_preset = {
      \'a'    : '#S',
      \'win'  : ['#I', '#W'],
      \'cwin' : ['#I', '#W', '#F'],
      \'y'    : ['%R', '%a', '%Y'],
      \'z'    : '#H'}

call plug#end()

" Spacing
"
" Insert spaces insted of tab characters
set expandtab
"
" Number of columns reserved for line numbers
set numberwidth=2
"
" Number of spaces to use for an indent
set shiftwidth=2
"
" Number of spaces to insert for a tab
set softtabstop=2
"
" Visual width of a tab character (ASCII 0x09)
set tabstop=8
"
" Length past which lines will be broken automatically
"set textwidth=79
set textwidth=0


" Verbosity
"
" Show lines that don't fit as @@@ and nonprintable characters as hexadecimal
if (v:version >= 800)
  set display=
  set display+=lastline
  set display+=uhex
endif
"
" Display line numbers
set number
"
" Display line numbers relative to current line
"set relativenumber
"
" Display cursor coordinates (e.g. LINE,COLUMN)
set ruler
"
" Display most recent command below window
set showcmd
"
" Briefly jump to match upon completing pair in 'matchpairs'
set showmatch
"
" Do not Update terminal titles
set notitle
"
" Hide text with the "conceal" syntax attribute
set conceallevel=3
"
" Never hide status line
set laststatus=2
"
" Define terminal titles
"let &titlestring = "%t%( [%M%R]%)%( (%{expand(\"%:p:~:h\")})%)%<"


" Cursor
"
" Attempt to preserve cursor position when moving linewise
set nostartofline
"
" Allow backspacing over everything in insert mode
set backspace=indent,eol,start
"
" Highlight current line number
if (exists('+cursorlineopt'))
  set cursorline
  set cursorlineopt=number
endif
"
" Lines of padding between cursor and edge of window
set scrolloff=3
"
" If 'nowrap' is set, minimum number of columnss to scroll at a time
set sidescroll=1
"
" If 'nowrap' is set, columns of padding between cursor and edge of window
set sidescrolloff=3
"
" Allow visual-block selection of empty columns
set virtualedit=block
"
" Move across lines with <Backspace>, <Space>, <Left> and <Right>
set whichwrap=b,s,[,],<,>

" Patterns
"
" Only highlight the current match
set nohlsearch
"
" Search forward as pattern is typed
set incsearch
"
" Ignore case by default
set ignorecase
"
" Respect case if pattern contains uppercase
set smartcase
"
" Additional bases recognized for increment/decrement
set nrformats=
set nrformats+=bin
set nrformats+=hex


" Buffers and Windows
"
" Split windows off toward the right
set splitright
"
" Split windows off toward the bottom
set splitbelow
"
" Re-read file if it was changed, unless it was deleted
set autoread
"
" Hide closed buffers rather than unloading them
set hidden
"
" Enable pseudo-transparency for floating windows
if (exists('+pumblend'))
  set pumblend=10
endif
"
" Enable pseudo-transparency for floating windows
if (exists('+winblend'))
  set winblend=10
endif
"
" Use a popup window for previews
if (exists('+previewpopup'))
  set previewpopup=highlight:PmenuThumb
endif


" Line Wrapping
"
" Do not wrap lines
"set nowrap
"
" Break lines before window edge
"set linebreak
"
" Indent wrapped lines
"set breakindent
"
" Break lines at these characters
"let &breakat = " \t;:"
"
" Prefix wrapped lines
"let &showbreak = "> "


" History
"
" Number of search patterns and ``:'' commands to remember (max: 10000)
set history=10000
"
" Number of modifications to remember for a given file
set undolevels=2500
"
" Always save entire buffer for undo when reloading it
set undoreload=-1
"
" Max characters typed between swapfile syncs
set updatecount=64
"
" Max milliseconds elapsed between swapfile syncs (also used by gitgutter)
set updatetime=100


" Key Timeout
"
" Timeout on mappings
set timeout
"
" milliseconds to wait for completion of a mapping
set timeoutlen=1000
"
" Don't timeout on keycodes
"set nottimeout
"
" milliseconds to wait if timing out on completion of a key code
"set ttimeoutlen=50


" Completion and Tags
"
" Enable insert-mode completion types
set complete=.,w,b,u,t,i
"
" Configure insert-mode completion
if (exists("&completepopup"))
  " Enable completion popup window in vim
  set completeopt=menuone,noselect,preview,popup
  set completepopup=height:15,highlight:Pmenu,border:off
else
  set completeopt=menuone,noselect,preview
endif
"
" Enable command-mode completion
set wildmenu
"
" Ignore version control directories
set wildignore+=*/.git/*,*/.hg/*,*/.svn/*
"
" Ignore filename case
set wildignorecase
"
" Configure command-mode completion
set wildmode=
set wildmode+=longest:full
set wildmode+=full
"
" Check for tags in the following files
set tags=
set tags+=tags
set tags+=.tags
set tags+=./tags
set tags+=./.tags
"
" Use arrow keys to move the cursor rather than select completions
cnoremap <Left>  <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
"
" Set omnifunc fallback
if (has("autocmd") && exists("+omnifunc"))
  autocmd rc Filetype *
        \ if (&omnifunc == '') |
        \ silent! setlocal omnifunc=syntaxcomplete#Complete |
        \ endif
endif


" Swapfiles and Undofiles
"
" Check undofile capability and use if using swapfile
if (has('persistent_undo'))
  let &undofile = &swapfile
endif
"
" Clear swap / undo directory preferences
set directory=
set undodir=
set backupdir=
"
" Append XDG_DATA_HOME if non-null
if (!empty($XDG_DATA_HOME))
  set directory+=$XDG_DATA_HOME/vim/swap/
  set undodir+=$XDG_DATA_HOME/vim/undo/
  set backupdir+=$XDG_DATA_HOME/vim/backup/
endif
"
" Append XDG_CACHE_HOME if non-null
if (!empty($XDG_CACHE_HOME))
  set directory+=$XDG_CACHE_HOME/vim/swap/
  set undodir+=$XDG_CACHE_HOME/vim/undo/
  set backupdir+=$XDG_CACHE_HOME/vim/backup/
endif
"
" Append TMPDIR if non-null
if (!empty($TMPDIR))
  set directory+=$TMPDIR/vim/swap/
  set undodir+=$TMPDIR/vim/undo/
  set backupdir+=$TMPDIR/vim/backup/
endif
"
" Append first element of 'runtimepath'
if (!empty(split(&runtimepath, ',')))
  if (empty(&directory))
    let &directory = split(&runtimepath, ',')[0] . '/swap/'
  else
    let &directory .= ',' . split(&runtimepath, ',')[0] . '/swap/'
  endif
  if (empty(&undodir))
    let &undodir = split(&runtimepath, ',')[0] . '/undo/'
  else
    let &undodir .= ',' . split(&runtimepath, ',')[0] . '/undo/'
  endif
  if (empty(&backupdir))
    let &backupdir = split(&runtimepath, ',')[0] . '/backup/'
  else
    let &backupdir .= ',' . split(&runtimepath, ',')[0] . '/backup/'
  endif
endif
"
" Create the primary swap directory
if (!isdirectory(split(&directory, ',')[0]))
  silent! call mkdir(split(&directory, ',')[0], 'p', 0700)
endif
"
" Create the primary undo directory
if (!isdirectory(split(&undodir, ',')[0]))
  silent! call mkdir(split(&undodir, ',')[0], 'p', 0700)
endif
"
" Create the primary backup directory
if (!isdirectory(split(&backupdir, ',')[0]))
  silent! call mkdir(split(&backupdir, ',')[0], 'p', 0700)
endif


" Terminal
"
" F**k terminal bells
set belloff=all


" Grep
"
" Use ripgrep instead
if (executable('rg') == 1)
  let &grepprg = 'rg --vimgrep --smart-case --unrestricted -- $* -'
endif


" Mouse
"
" Enable the mouse
if (has('mouse'))
  set mouse=a
  if (has('mouse_sgr'))
    set ttymouse=sgr
  endif
  if (exists('+mousefocus'))
    set mousefocus
  endif
endif


" ColorColumn
"
" Define a function to apply 'colorcolumn' to all columns past 'textwidth'
let &colorcolumn = join(map(range(1, winwidth(0)), '"+" . v:val'), ',')
"
" Update 'colorcolumn' upon resizing a window
if (has('autocmd'))
  autocmd rc BufEnter,VimEnter,VimResized,WinEnter *
        \ silent! let &colorcolumn = join(map(range(1, winwidth(0)), '"+" . v:val'), ',')
endif


" Colors and Colorschemes
"
" Check COLORTERM
if ($COLORTERM =~? '^\s*truecolor\s*$')
  let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
  let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
endif
"
" Check type of terminal
if (exists('+termguicolors'))
  if ($TERM =~ '^\%(alacritty\|st\|tmux\|iterm2\?\|vte\)\%(-.*\)\?$')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    set termguicolors
  elseif ($TERM =~ '^\%(linux\|rxvt\|screen\|interix\|putty\)\%(-.*\)\?$')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    set notermguicolors
  elseif ($TERM =~ '^\%(xterm\)\%(-.*\)\?$')
    let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum"
    let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum"
    if ($XTERM_VERSION  != '' || $VTE_VERSION != '' || $KONSOLE_PROFILE_NAME != '')
      set termguicolors
    else
      set notermguicolors
    endif
  endif
endif
"
" Choose some colors
let g:colorschemes = [
      \ 'kolor',
      \ 'colorsbox-steighties',
      \ 'night-owl',
      \ 'night_owl_light',
      \ 'janah',
      \ 'snazzy',
      \ 'Tomorrow',
      \ 'desert',
      \ 'evening',
      \ 'habamax',
      \ 'lunaperche',
      \ 'shine',
      \ 'sorbet',
      \ 'vim',
      \ 'wildcharm',
      \ 'zaibatsu',
      \ ]

" Set a colorscheme
execute 'colorscheme' g:colorschemes[0]
"
" Define a function to rotate the colorscheme
function! RotateColorscheme(n)
  if (exists('g:colorschemes'))
    try
      let l:size = len(g:colorschemes)
    catch /^Vim(let)\=:E121/
      let l:size
    endtry
    let l:shift = a:n % l:size
    let g:colorschemes = slice(g:colorschemes, shift) + slice(g:colorschemes, 0, shift)
    try
      execute 'colorscheme' g:colorschemes[0]
    catch /^Vim(colorscheme):/
    endtry
  endif
endfunction
"
" F10:
" Rotate to next colorscheme
nnoremap <silent> <F10> :call RotateColorscheme(1)<CR>
" M-F10 (a.k.a. F58):
" Rotate to previous colorscheme
nnoremap <silent> <M-F10> :call RotateColorscheme(-1)<CR>
nnoremap <silent> <F58> :call RotateColorscheme(-1)<CR>


" C / C++
"
" Highlight strings & numbers inside comments
let g:c_comment_strings = 1
"
" Highlight GNU specific items
let g:c_gnu = 1
"
" Highlight space errors
let g:c_space_errors = 1
"
" Set local options for C and C++ files
if (has('autocmd'))
  autocmd rc FileType c,cpp
        \ silent! setlocal cin noet sts=0 sw=8 ts=8 tw=119
        \|silent! let &l:shiftwidth = &tabstop
        \|silent! let &l:cinoptions = ':0,(' . &tabstop
endif


" gitcommit
"
" Set textwidth for commit messages
if (has('autocmd'))
  autocmd rc FileType gitcommit
        \ silent! setlocal tw=55
endif


" help
"
" Set local options when getting help
if (has("autocmd"))
  autocmd rc FileType help
        \ silent! setlocal cc= noswf noudf tw=0
endif
"
" Split help windows vertically
nmap <leader>K
      \ :let &keywordprg = substitute(&keywordprg, '^\s*:', ':vert ', '')<CR>K<Esc>
      \ :let &keywordprg = substitute(&keywordprg, '^:vert \s*', ':', '')<CR>


" man page
"
" Load the Man plugin
runtime ftplugin/man.vim
"
let g:man_hardwrap=0
"
" Use K to open man pages
set keywordprg=:Man
"
"Set local options for man pages
if (has('autocmd'))
  autocmd rc FileType man
        \ silent! setlocal cc= nohid noma nonu nornu noswf noudf tw=0
endif


" markdown
"
" Set local options for markdown documents (e.g. README, etc.)
if (has('autocmd'))
  if (has('linebreak'))
    autocmd rc FileType markdown
          \ silent! setlocal cc= nonu nornu wrap lbr bri
  else
    autocmd rc FileType markdown
          \ silent! setlocal cc= nonu nornu wrap
  endif
endif


" Python
"
" Set local options for python scripts
if (has('autocmd'))
  autocmd rc FileType python
        \ silent! setlocal et sts=4 sw=4 ts=8 tw=79
endif

" Enable all available highlighting
let g:python_highlight_all = 1
"
" Enable syntastic plugins
let g:syntastic_python_checkers = ['pycodestyle', 'pylint', 'python']
"
" Set the default version for pyx commands
if (has('pythonx'))
  if (has('python3'))
    set pyxversion=3
  elseif (has('python2'))
    set pyxversion=2
  endif
endif


" readline
"
" Highlight bash additions
let g:readline_has_bash = 1


" sed
"
" Highlight real tabs in sed scripts
let g:highlight_sedtabs = 1


" sh
"
" Default highlighting for shell scripts
let g:is_posix = 1
"
" Fold functions and if/do/for clauses
let g:sh_fold_enabled = 3
"
" Relax error detection
let g:sh_no_error = 1
"
" Set local options when opening a shell script
if (has("autocmd"))
  autocmd rc FileType bash,ksh,sh,zsh
        \ silent! setlocal et sts=2 sw=2 ts=8 tw=119
endif
"
" Set filetype to sh when editing a shell command line
if (has("autocmd"))
  autocmd rc BufRead bash-fc.*
        \ silent! setlocal et ft=sh noswf noudf
        \|silent! let b:is_bash = 1
        \|silent! syntax enable
endif


" Airline
"
"let g:airline_powerline_fonts = 1
"let g:airline_left_sep = "\UE0C0"
"let g:airline_right_sep = "\UE0C2"
"let g:airline_left_alt_sep = "\UE0B1"
"let g:airline_right_alt_sep = "\UE0B3"
"
"if (!exists('g:airline_symbols'))
"  let g:airline_symbols = {}
"endif

let g:airline#extensions#tabline#enabled = 1
let g:airline#extensions#tabline#formatter = "unique_tail_improved"
let g:airline#extensions#tabline#overflow_marker = '…'
let g:airline#extensions#tabline#buffer_nr_show = 1
let g:airline#extensions#tabline#fnamecollapse = 1
"
" Set some airline theme options
let g:airline_themes = [
      \ 'kolor',
      \ 'atomic',
      \ 'papercolor',
      \ 'soda'
      \ ]
let g:airline_theme = g:airline_themes[1]
eval('AirlineTheme' .. ' ' .. g:airline_theme)
"
"
" Define a function to rotate the colorscheme
function! RotateAirlineThemes(n)
  if (exists('g:airline_themes'))
    try
      let l:size = len(g:airline_themes)
    catch /^Vim(let)\=:E121/
      let l:size
    endtry
    let l:shift = a:n % l:size
    let g:airline_themes = slice(g:airline_themes, shift) + slice(g:airline_themes, 0, shift)
    try
      execute 'AirlineTheme' g:airline_themes[0]
    catch /^Vim(.*):/
    endtry
  endif
endfunction
"
" F11:
" Rotate to next airline theme
nnoremap <silent> <F11> :call RotateAirlineThemes(1)<CR>
"
" M-F11 (a.k.a. F59):
" Rotate to previous colorscheme
nnoremap <silent> <M-F11> :call RotateAirlineThemes(-1)<CR>
nnoremap <silent> <F59> :call RotateAirlineThemes(-1)<CR>
"
" Refresh airline when the colorscheme changes
if (has('autocmd'))
  autocmd rc ColorScheme *
        \ silent! AirlineRefresh
endif


" BufExplorer
"
let g:bufExplorerDefaultHelp = 0
let g:bufExplorerOnlyOneTab = 0
let g:bufExplorerShowNoName = 1
let g:bufExplorerShowTabBuffer = 1
let g:bufExplorerShowUnlisted = 1
"
" F8: Toggle the buffer explorer
nnoremap <silent> <F8> :ToggleBufExplorer<CR>


" CtrlP
"
let g:ctrlp_map = '<C-q>'
let g:ctrlp_cmd = 'Rz'
let g:ctrlp_switch_buffer = 'Et'
let g:ctrlp_show_hidden = 0
let g:ctrlp_mruf_exclude = '^\(.*/\)\?\.\?tmp\(/.*\)\?$'


" DevIcons
"
let g:webdevicons_enable = 1
let g:webdevicons_enable_airline_tabline = 1
let g:webdevicons_enable_airline_statusline = 1
let g:webdevicons_enable_ctrlp = 1
let g:webdevicons_enable_nerdtree = 1
let g:webdevicons_enable_startify = 1
let g:webdevicons_conceal_nerdtree_brackets = 1
let g:DevIconsEnableFoldersOpenClose = 1
let g:DevIconsEnableNERDTreeRedraw = 1
let g:DevIconsAppendArtifactFix = 1
let g:WebDevIconsNerdTreeGitPluginForceVAlign = 1
let g:WebDevIconsUnicodeDecorateFileNodes = 1
let g:WebDevIconsUnicodeDecorateFolderNodes = 1
let g:WebDevIconsTabAirLineAfterGlyphPadding = ' '
let g:WebDevIconsTabAirLineBeforeGlyphPadding = ' '
"
" Fix syntax matching issues (concealing brackets) when re-sourcing
if (exists('g:loaded_webdevicons'))
  call webdevicons#refresh()
endif


" GitGutter
"
" Set sign colors automatically
let g:gitgutter_set_sign_backgrounds = 1
"
" F7: Toggle GitGutter
nnoremap <silent> <F7> :GitGutterBufferToggle<CR>
"
" Bring colorscheme harmony
highlight! link SignColumn LineNr
if (has('autocmd'))
  autocmd rc ColorScheme *
        \ highlight! link SignColumn LineNr
endif

"" Disable GitGutter
"if (has('autocmd'))
"  autocmd rc BufRead *
"    \ silent! GitGutterBufferDisable
"endif


" ListToggle
"
" Toggle the location list
let g:lt_location_list_toggle_map = '<leader>l'
let g:lt_quickfix_list_toggle_map = '<leader>q'


" NERDTree
"
" Disable arrow icons at the left side of folder icons
let g:NERDTreeDirArrowExpandable  = ""
let g:NERDTreeDirArrowCollapsible = ""
"
" Separate filenames from icons
let NERDTreeNodeDelimiter="\u00a0"
"
" Disable the "Bookmarks" label
let g:NERDTreeMinimalUI = 1
"
" Single click to open directories
let g:NERDTreeMouseMode = 2
"
" F9: Toggle the file explorer
nnoremap <silent> <F9> :NERDTreeToggle<CR>


" Startify
"
let g:startify_fortune_use_unicode = 1
let g:startify_update_oldfiles = 1


" Syntastic
"
let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 0
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
let g:syntastic_check_on_w = 1
let g:syntastic_mode_map = {
  \   "mode": "active",
  \   "active_filetypes": [],
  \   "passive_filetypes": ["python"]
  \ }


" Tagbar
"
" F10: Toggle the tagbar
nnoremap <silent> <F10> :TagbarToggle<CR>


" YouCompleteMe
"
if (has("quickfix") && has("textprop") && exists("+completepopup"))
  let g:ycm_add_preview_to_completeopt = 'popup'
else
  let g:ycm_add_preview_to_completeopt = 1
endif
let g:ycm_auto_hover = ''
let g:ycm_auto_trigger = 1
let g:ycm_autoclose_preview_window_after_completion = 0
let g:ycm_autoclose_preview_window_after_insertion = 0
let g:ycm_collect_identifiers_from_tags_files = 1
let g:ycm_complete_in_comments = 1
let g:ycm_confirm_extra_conf = 0
let g:ycm_key_invoke_completion = '<C-Space>'
let g:ycm_key_list_previous_completion = ['<S-Tab>', '<Up>']
let g:ycm_key_list_select_completion = ['<Tab>', '<Down>']
let g:ycm_key_list_stop_completion = ['<C-y>', '<Enter>']
let g:ycm_max_num_candidates = 60
let g:ycm_max_num_identifier_candidates = 12
let g:ycm_min_num_of_chars_for_completion = 3
let g:ycm_seed_identifiers_with_syntax = 0
let g:ycm_global_ycm_extra_conf =
  \ split(&runtimepath, ',')[0] . '/autoload/ycm_extra_conf.py'

" Toggle preview window
nmap <silent> <leader><leader> <plug>(YCMHover)

if (has('autocmd'))
  autocmd rc FileType c,cpp
    \ let b:ycm_hover = {
    \   'command': 'GetDoc',
    \   'syntax': &filetype,
    \ }
endif


" fzf
"
" Bring colorscheme harmony
let g:fzf_colors = {
      \ 'fg':       ['fg', 'Normal'],
      \ 'bg':       ['bg', 'Normal'],
      \ 'hl':       ['fg', 'MatchParens'],
      \ 'fg+':      ['fg', 'CursorLine', 'CursorColumn', 'Normal'],
      \ 'bg+':      ['bg', 'CursorLine', 'CursorColumn'],
      \ 'hl+':      ['fg', 'Statement'],
      \ 'info':     ['fg', 'PreProc'],
      \ 'border':   ['fg', 'Ignore'],
      \ 'prompt':   ['fg', 'Conditional'],
      \ 'pointer':  ['fg', 'Exception'],
      \ 'marker':   ['fg', 'Keyword'],
      \ 'spinner':  ['fg', 'Label'],
      \ 'header':   ['fg', 'Comment'],
      \ }
"
" Set fzf window layout
if (empty($TMUX) || empty($FZF_TMUX))
  let g:fzf_layout = {'window': join([
        \ 'split', 'belowright', join([float2nr(winheight(0) * 0.42),  'new'], '')
        \ ])}
else
  let g:fzf_layout = {'tmux': join([
        \ '-d', empty($FZF_TMUX_HEIGHT) ? '42%' : $FZF_TMUX_HEIGHT
        \ ])}
endif
"
let g:fzf_command_prefix = ''
let g:fzf_commands_expect = 'alt-enter,ctrl-x'
let g:fzf_buffers_jump = 1
let g:fzf_tags_command = 'ctags -f .tags -R'
"
"
" Select files
command! -bang -nargs=? -complete=dir Files
      \ call fzf#vim#files(
      \   <q-args>,
      \   fzf#vim#with_preview(
      \     fzf#wrap({
      \       'options': [
      \         '--bind=tab:down,shift-tab:up',
      \         '--info=inline',
      \         '--layout=reverse',
      \         ]
      \       })
      \     ),
      \   <bang>0
      \ )
"
"
" Select files with ripgrep
function! Rz(query, fullscreen)
  let l:commandfmt = 'rg --no-column --no-heading --line-number --color=always --smart-case -- %s || true'
  let l:command = printf(l:commandfmt, shellescape(a:query))
  let l:command_reload = printf(l:commandfmt, '{q}')
  let l:spec = fzf#wrap({
        \ 'options': ['--disabled', '--layout=reverse', '--query', a:query, '--bind',
        \     join(['change', 'reload', l:command_reload, ''], ':')]
        \ })
  call fzf#vim#grep(l:command, 0, fzf#vim#with_preview(l:spec), a:fullscreen)
endfunction
"
command! -nargs=* -bang Rz call Rz(<q-args>, <bang>0)
"
"
" Select colorschemes
function! Colors(query, fullscreen)
  let l:options = [
        \ '--cycle',
        \ '--bind=tab:down,shift-tab:up',
        \ '--info=hidden',
        \ '--layout=reverse',
        \ '--query', a:query,
        \ ]
  let l:source = map(split(globpath(&rtp, "colors/*.vim")), "fnamemodify(v:val, ':t:r')")
  if (empty($TMUX) || empty($FZF_TMUX))
    let l:spec = {
          \ 'options': l:options, 'source': l:source, 'sink': 'color',
          \ 'window': join([
          \   'vertical', 'aboveleft', join([float2nr(winwidth(0) * 0.28), 'new'], '')
          \ ])
          \ }
  else
    let l:spec = {
          \ 'options': l:options, 'source': l:source, 'sink': 'color',
          \ 'tmux': join(['-d', empty($FZF_TMUX_HEIGHT) ? '42%' : $FZF_TMUX_HEIGHT])
          \ }
  endif
  call fzf#run(fzf#wrap(l:spec, a:fullscreen))
endfunction
"
command! -nargs=* -bang Colors call Colors(<q-args>, <bang>0)
"
"
" F1:
" Find buffers
nnoremap <silent> <F1> :Buffers<CR>
inoremap <silent> <F1> <Esc>:Buffers<CR>
nnoremap <silent> <Esc><F1> :Buffers!<CR>
inoremap <silent> <Esc><F1> <Esc>:Buffers!<CR>

" F2:
" Find helptags
nnoremap <silent> <F2> :Helptags<CR>
inoremap <silent> <F2> <Esc>:Helptags<CR>
nnoremap <silent> <Esc><F2> :Helptags!<CR>
inoremap <silent> <Esc><F2> <Esc>:Helptags!<CR>

" F3:
" Find commands
nnoremap <silent> <F3> :Commands<CR>
inoremap <silent> <F3> <Esc>:Commands<CR>
nnoremap <silent> <Esc><F3> :Commands!<CR>
inoremap <silent> <Esc><F3> <Esc>:Commands!<CR>

" F4:
" Find helptags
nnoremap <silent> <F4> :Helptags<CR>
inoremap <silent> <F4> <Esc>:Helptags<CR>
nnoremap <silent> <Esc><F4> :Helptags!<CR>
inoremap <silent> <Esc><F4> <Esc>:Helptags!<CR>



" Tabs
"
" Create a tab
nnoremap <silent> <leader>c :tabnew<CR>
"
" Destroy a tab
nnoremap <silent> <leader>x :tabclose<CR>
"
" Go to the next tab
nnoremap <silent> <C-PageUp> :tabnext<CR>
"
" Go to the previous tab
nnoremap <silent> <C-PageDown> :tabprev<CR>


" Paste mode
"
"set pastetoggle=<Insert>
"
" Insert:
" Toggle paste mode
nnoremap <silent> <Insert>
      \ : set paste!<CR>


" Misc
"
" F5: Toggle search highlighting
nnoremap <silent> <F5>
      \ : setlocal hlsearch!<CR>
"
" F6: Toggle line numbers
"nnoremap <silent> <F6>
"  \ : let &l:nu = !&l:nu<Bar>
"  \   let &l:rnu = &l:nu<CR>
nnoremap <silent> <F6>
      \ : let &l:nu = !&l:nu<CR>
"
" Insert a shebang above the first line
"nnoremap <silent> <leader>#!
"  \ ggI<C-R>=substitute(&ft, "..*", "#!" . exepath(&ft) . "\\r", "")<CR><Esc>``
"
" Copy the current visual selection to the clipboard
vnoremap <silent> - "+y
nnoremap <silent> - "+y
"
" Paste the contents of the clipboard
vnoremap <silent> + "+p
nnoremap <silent> + "+p
"
" Search forward for the current visual selection
" Note: Jumping to a tag does not set the current search pattern
vnoremap <silent> *
      \ : <C-U>let old_reg=getreg('"')<Bar>
      \   let old_regtype=getregtype('"')<CR>
      \   gvy/<C-R><C-R>=substitute(
      \   escape(@",'/\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
      \   gV:call setreg('"',old_reg,old_regtype)<CR>
"
" Search backward for the current visual selection
" Note: Jumping to a tag does not set the current search pattern
vnoremap <silent> #
      \ : <C-U>let old_reg=getreg('"')<Bar>let old_regtype=getregtype('"')<CR>
      \   gvy?<C-R><C-R>=substitute(
      \   escape(@",'?\.*$^~['),'\_s\+','\\_s\\+','g')<CR><CR>
      \   gV:call setreg('"',old_reg,old_regtype)<CR>


" Epilogue
"
" Allow options to be set from a modeline
set modeline
"
" Restrict editor if SWIM owns this file
set secure


" vi:et:ft=vim:sts=2:sw=2:ts=8:tw=119
